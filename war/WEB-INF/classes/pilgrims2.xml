<?xml version="1.0" encoding="utf-8" ?> 
<scxml xmlns="http://www.w3.org/2005/07/scxml" 
	xmlns:game="http://www.livegameengine.com/schemas/game.xsd" 
	initialstate="initializing">
	
	<datamodel>
		<script><![CDATA[
			p = "http://www.livegameengine.com/schemas/pilgrims.xsd";
			g = "http://www.livegameengine.com/schemas/game.xsd";
			s = "http://www.w3.org/2005/07/scxml";
			sns = new Namespace(s);
			gns = new Namespace(g);
			pns = new Namespace(p);
			default xml namespace = p;
			
			
			function isCurrentPlayer(playerId) {
				return playerId == state.board.players.player[state.board.currentPlayer].playerId.text();
			}
			function shuffle(arr) {
				var len = arr.length;
				for(var i = 0; i < len; i++) {
					var p = Math.floor(Math.random() * len);
					var t = arr[i];
					arr[i] = arr[p];
					arr[p] = t;
				}
			}
			function initializePlayer(playerid) {
				var colors = state.template.playerTemplate.@colors.toString().split(" ");
				var playerColor = colors[state.board.players.player.length()];
				var player = <player>
					<playerId>{playerid}</playerId>
					<color>{playerColor}</color>
					<resources privateOf="../*[local-name() = 'playerId']/text()" />
				</player>;
				
				for(var i = 0; i < state.template.playerTemplate.*.length(); i++) {
					player.appendChild(state.template.playerTemplate.child(i));
				}
				for(var i = 0; i < state.board.resources.resource.length(); i++) {
					var res = state.board.resources.resource[i];
					player.resources.appendChild(<resource type={res.@type} count="0" />);
				}
				state.board.players.appendChild(player);
				
				return playerColor;
			}
			function polyCorners(x, y) {
				x = parseInt(x);
				y = parseInt(y);
				return [
					{ x: 1 + x, y: 0 + y },
					{ x: 3 + x, y: 0 + y },
					{ x: 4 + x, y: 1 + y },
					{ x: 3 + x, y: 2 + y },
					{ x: 1 + x, y: 2 + y },
					{ x: 0 + x, y: 1 + y }
				];
			}
			function instantiateTemplate() {
				var board = state.board;
				var template = state.template;
				
				var index = new Object();
				
				for(var i = 0; i < template.polys.poly.length(); i++) {
					var p = template.polys.poly[i];
					
					var pv = polyCorners(p.@x, p.@y);
					var last = pv[pv.length - 1];
					
					function s(p) { return "(" + p.x + "," + p.y + ")"; };
					function e(p1,p2) { return "(" + p1.x + "," + p1.y + "," + p2.x + "," + p2.y + ")"; };
					
					for(var j = 0; j < pv.length; j++) {
						//log.info("corner: " + j + ", of poly " + i);
						var c = pv[j];
						
						if(!index[s(c)]) {
							//log.info("adding point: " + s(c));
							board.verteces.appendChild(<vertex x={c.x} y={c.y} />);
							index[s(c)] = true;
						}
						
						if((last.x < c.x || (last.x == c.x && last.y < c.y)) && !index[e(last,c)]) {
							board.edges.appendChild(<edge x1={last.x} y1={last.y} x2={c.x} y2={c.y} />);
							index[e(last,c)] = true;
						}
						else if((last.x > c.x || (last.x == c.x && last.y > c.y)) && !index[e(c,last)]) {
							board.edges.appendChild(<edge x2={last.x} y2={last.y} x1={c.x} y1={c.y} />);
							index[e(c,last)] = true;
						}
						
						last = c;
					}
					
					board.polys.appendChild(<poly x={p.@x} y={p.@y} />);
				}
			}
			function findVertex(x, y) {
				return state.board.verteces.vertex.(@x==( x >>> 0) && @y== (y >>> 0))[0];
			}
			function findEdge(x1,y1,x2,y2) {
				return state.board.edges.edge.(@x1 == _eventdata.edge.@x1 && @y1 == _eventdata.edge.@y1 && @x2 == _eventdata.edge.@x2 && @y2 == _eventdata.edge.@y2)[0];
			}
			function hasDevelopment(obj) {
				return !!obj && !!obj.development && obj.development.length() > 0;
			}
			function hasAdjacentDevelopment(x, y) {
				var adjacent = adjacentVertexFromVertex(x, y);
				
				for(var i = 0; i < adjacent.length(); i++) {
					var v = adjacent[i];
					if(v.development.length() > 0)
						return true;
				}
				return false;
			}
			function placeVertexDevelopment(dev, col, x, y) {
				log.info("placing development: " + dev + "-" + col + " " + x + "," + y);
				var p = state.board.players.player.(color == col)[0];
				var pd = p.development.(@type == dev)[0];
				var v = state.board.verteces.vertex.(@x==x && @y==y)[0];
				
				//log.info("player: " + pId + ":" + p);
				//log.info("vertex: " + v.toXMLString());
				
				v.appendChild(<development type={pd.@type} color={col} count="1" />);
				pd.@count -= 1;
			}
			function placeEdgeDevelopment(dev, col, x1, y1, x2, y2) {
				log.info("placing development: " + dev + "-" + col.text() + " " + x1 + "," + y1 + "," + x2 + "," + y2);
				var p = state.board.players.player.(color == col)[0];
				var pd = p.development.(@type == dev)[0];
				var e = state.board.edges.edge.(@x1==x1 && @y1==y1 && @x2==x2 && @y2==y2)[0];
				
				//log.info("player: " + pId + ":" + p);
				//log.info("vertex: " + v.toXMLString());
				
				e.appendChild(<development type={pd.@type} color={col} count="1" />);
				pd.@count -= 1;
			}
			function adjacentVertexFromPoly(x, y) {
				var corners = polyCorners(x, y);
				
				var ret = <></>;
				
				for(var i = 0; i < corners.length; i++) {
					var c = corners[i];
					
					ret += state.board.verteces.vertex.(@x == c.x && @y == c.y);
				}
				
				return ret;
			}
			function adjacentVertexFromVertex(x, y) {
				var edges1 = state.board.edges.edge.(@x1 == x && @y1 == y);
				var edges2 = state.board.edges.edge.(@x2 == x && @y2 == y);
				
				var ret = <></>;
				
				for(var i = 0; i < edges1.length(); i++) {
					var edge = edges1[i];
					ret += state.board.verteces.vertex.(@x == edge.@x2 && @y == edge.@y2);
				}
				for(var i = 0; i < edges2.length(); i++) {
					var edge = edges2[i];
					ret += state.board.verteces.vertex.(@x == edge.@x1 && @y == edge.@y1);
				}
				return ret;
			}
			function adjacentPolyFromVertex(x, y) {
				log.info("looking for adjecencies to " + x + ", " + y);
				var ret = <></>;
				
				for(var i = 0; i < state.board.polys.poly.length(); i++) {
					var p = state.board.polys.poly[i];
					var corners = polyCorners(p.@x, p.@y);
															
					for(var j = 0; j < corners.length; j++) {
						var c = corners[j];
						
						if(c.x == parseInt(x) && c.y == parseInt(y)) {
							ret += p;
							break;
						}
					}
				}
				
				return ret;
			}
			function distributeAdjacentResources(player, x, y) {
				var adjacentPolys = adjacentPolyFromVertex(x, y);
				log.info("found " + adjacentPolys.length() + " adjacent polys to " + _eventdata.vertex.@x + ", " + _eventdata.vertex.@y);
				
				for(var i = 0; i < adjacentPolys.length(); i++) {
					var p = adjacentPolys[i];
					
					var produces = state.board.polytypes.polytype.(@type == p.@type).@produces;
					var pr = player.resources.resource.(@type == produces);
					
					pr.@count = parseInt(pr.@count) + 1;								
				}
			}
		]]></script>
		<data name="state">
			<template xmlns="http://www.livegameengine.com/schemas/pilgrims.xsd">
				<playerTemplate colors="red green blue orange">
					<development type="settlement" count="5" />
					<development type="city" count="4" />
					<development type="road" count="15" />
				</playerTemplate>
				
				<polys values="5 2 6 3 8 10 9 12 11 4 8 10 9 4 5 6 3 11">
					<poly x="0" y="2" />
					<poly x="3" y="1" />
					<poly x="6" y="0" />
					<poly x="9" y="1" />
					<poly x="12" y="2" />
					<poly x="12" y="4" />
					<poly x="12" y="6" />
					<poly x="9" y="7" />
					<poly x="6" y="8" />
					<poly x="3" y="7" />
					<poly x="0" y="6" />
					<poly x="0" y="4" />
					<poly x="3" y="3" />
					<poly x="6" y="2" />
					<poly x="9" y="3" />
					<poly x="9" y="5" />
					<poly x="6" y="6" />
					<poly x="3" y="5" />
					<poly x="6" y="4" />
				</polys>
				<ports>
					<port tradeIn="2" tradeOut="1" resource="Ore" />
					<port tradeIn="2" tradeOut="1" resource="Grain" />
					<port tradeIn="2" tradeOut="1" resource="Wool" />
					<port tradeIn="2" tradeOut="1" resource="Brick" />
					<port tradeIn="2" tradeOut="1" resource="Wood" />
					<port tradeIn="3" tradeOut="1" />
					<port tradeIn="3" tradeOut="1" />
					<port tradeIn="3" tradeOut="1" />
					<port tradeIn="3" tradeOut="1" />
					<locations>
						<vertex x="10" y="1" />	<vertex x="12" y="1" />
						<vertex x="15" y="2" /> <vertex x="16" y="3" />
						<vertex x="16" y="5" /> <vertex x="15" y="6" />
						<vertex x="13" y="8" /> <vertex x="12" y="9" />
						<vertex x="9" y="10" /> <vertex x="7" y="10" />
						<vertex x="4" y="9" /> <vertex x="3" y="8" />
						<vertex x="1" y="6" /> <vertex x="0" y="5" />
						<vertex x="0" y="3" /> <vertex x="1" y="2" />
						<vertex x="4" y="1" /> <vertex x="6" y="1" />
					</locations>
				</ports>
				
			</template>
			<board xmlns="http://www.livegameengine.com/schemas/pilgrims.xsd">
				<maxPlayers>4</maxPlayers>
				<minPlayers>2</minPlayers>
				<currentPlayer>0</currentPlayer>
				<polys/>
				<verteces/>
				<edges/>
				<players/>
				<polytypes>
					<polytype type="Mountains" count="3" produces="Ore" />
					<polytype type="Fields" count="4" produces="Grain" />
					<polytype type="Pasture" count="4" produces="Wool" />
					<polytype type="Hills" count="3" produces="Brick" />
					<polytype type="Forest" count="4" produces="Wood" />
					<polytype type="Desert" count="1" />
				</polytypes>
				<resources>
					<resource type="Ore" />
					<resource type="Grain" />
					<resource type="Wool" />
					<resource type="Brick" />
					<resource type="Wood" />
				</resources>
				<developments>
					<development type="settlement" cost="1 Grain, 1 Wool, 1 Brick, 1 Wood" />
					<development type="city" cost="3 Ore, 2 Grain" />
					<development type="road" cost="1 Wood, 1 Brick" />
				</developments>
			</board>
		</data>
	</datamodel>
	
	<state id="initializing">
		<transition target="waitingForPlayers" />
	</state>

	<state id="waitingForPlayers">
		<transition event="game.playerJoin" cond="state.board.players.player.length() + 1 &gt; parseInt(state.board.maxPlayers)">
			<game:error messageExpr="'You cannot excede the maximum of ' + parseInt(state.board.maxPlayers) + ' players.'" />
		</transition>
		<transition event="game.playerJoin">
			<script><![CDATA[
				var role = initializePlayer(_eventdata.text());
			]]></script>
			<game:playerJoin roleExpr="role" />
		</transition>
	
		<transition event="game.startGame" cond="state.board.players.player.length() &lt; parseInt(state.board.minPlayers)">
			<game:error messageExpr="'You cannot start until you have ' + parseInt(state.board.minPlayers) + ' players.'" />
		</transition>
		<transition event="game.startGame" target="createBoard" />
	</state>
	
	<state id="createBoard">
		<onentry>
			<script><![CDATA[
				instantiateTemplate();
				
				var tilesenum = new Array();
				
				for(var i = 0; i < state.board.polytypes.polytype.length(); i++) {
					var pt = state.board.polytypes.polytype[i];
					var d = parseInt(pt.@count);
					
					while(d-- > 0) {
						tilesenum.push(pt.@type);
					} 
				}
				
				var polyproduces = new Object();
				
				for(var i = 0; i < state.board.polytypes.polytype.length(); i++) {
					var pt = state.board.polytypes.polytype[i];
					
					polyproduces[pt.@type.toString()] = pt.@produces.toString();
				}
				
				shuffle(tilesenum);
				
				var polyvalues = state.template.polys.@values.split(" ");
				
				for(var i = 0, j = 0; i < state.board.polys.poly.length() && i < tilesenum.length; i++) {
					var p = state.board.polys.poly[i];
					var t = tilesenum[i];
					var v = null;
					
					if(j < polyvalues.length) {
						v = polyvalues[j];
					}
					
					var prod = polyproduces[t];
					
					if(prod) {
						p.@value = v;
						p.@type = t.toString();
						j++;
					}
					else {
						p.@type = t;
					}
				}
				
				delete tilesenum;
				delete polyproduces;
				
				var ports = new Array();
				state.board.appendChild(<ports></ports>);
				
				for(var i = 0; i < state.template.ports.port.length(); i++) {
					ports[i] = i;
				}
				
				shuffle(ports);
				
				for(var i = 0; i < state.template.ports.locations.vertex.length(); i++) {
					var loc = state.template.ports.locations.vertex[i];
					var port = state.template.ports.port[ports[(i/2)>>>0]];
					
					var p = <port x={loc.@x} y={loc.@y} tradeIn={port.@tradeIn} tradeOut={port.@tradeOut} resource={port.@resource} />;
					 
					state.board.ports.appendChild(p);		
				}
				
				delete ports;
				
			]]></script>
		</onentry>
		<transition target="placement">
			<script><![CDATA[
				state.board.appendChild(<firstPlacement>true</firstPlacement>);
			]]></script>
			<game:startGame />
		</transition>
	</state>	
	
	<state id="placement" initial="placement.buildSettlement">
		<state id="placement.buildSettlement">
			<transition event="board.click" cond="!isCurrentPlayer(_eventdata.gns::player.text())">
				<game:error message="You are not the current player." />
			</transition>
			<transition event="board.click" cond="_eventdata.vertex.length() == 0">
				<game:error message="You must click on a vertex" />
			</transition>
			<transition event="board.click" cond="!findVertex(_eventdata.vertex.@x, _eventdata.vertex.@y)">
				<game:error messageExpr="'Vertex (' + _eventdata.vertex.@x + ',' + _eventdata.vertex.@y + ') does not exist'" />
			</transition>
			<transition event="board.click" cond="hasDevelopment(findVertex(_eventdata.vertex.@x, _eventdata.vertex.@y))">
				<game:error messageExpr="'Vertex (' + _eventdata.vertex.@x + ',' + _eventdata.vertex.@y + ') already has a development'" />
			</transition>
			<transition event="board.click" cond="hasAdjacentDevelopment(_eventdata.vertex.@x, _eventdata.vertex.@y)">
				<game:error messageExpr="'Vertex (' + _eventdata.vertex.@x + ',' + _eventdata.vertex.@y + ') has an adjacent development'" />
			</transition>
			<transition event="board.click" target="placement.buildRoad">
				<script><![CDATA[
					var player = state.board.players.player[state.board.currentPlayer];
					
					placeVertexDevelopment("settlement", player.color, _eventdata.vertex.@x, _eventdata.vertex.@y);
					state.board.appendChild(<currentVertex x={_eventdata.vertex.@x} y={_eventdata.vertex.@y} />);
						
					if(state.board.firstPlacement != "true") {
						distributeAdjacentResources(player, _eventdata.vertex.@x, _eventdata.vertex.@y);
					}
				]]></script>
				<game:sendWatcherEvent event="'placeVertexDevelopment'" keyExpr="_eventdata.vertex.@x + ',' + _eventdata.vertex.@y">
					<param name="color" expr="player.color" />
					<param name="x" expr="_eventdata.vertex.@x" />
					<param name="y" expr="_eventdata.vertex.@y" />
					<param name="type" expr="'settlement'" />
				</game:sendWatcherEvent>
			</transition>
		</state>
		<state id="placement.buildRoad">
			<transition event="board.click" cond="!isCurrentPlayer(_eventdata.gns::player.text())">
				<game:error message="You are not the current player." />
			</transition>
			<transition event="board.click" cond="_eventdata.edge.length() == 0">
				<game:error message="You must click on a edge" />
			</transition>
			<transition event="board.click" cond="!findEdge(_eventdata.edge.@x1, _eventdata.edge.@y1, _eventdata.edge.@x2, _eventdata.edge.@y2)">
				<game:error messageExpr="'Edge (' + _eventdata.edge.@x1 + ',' + _eventdata.edge.@y1 + ',' + _eventdata.edge.@x2 + ',' + _eventdata.edge.@y2 + ') does not exist'" />
			</transition>
			<transition event="board.click" cond="hasDevelopment(findEdge(_eventdata.edge.@x1, _eventdata.edge.@y1, _eventdata.edge.@x2, _eventdata.edge.@y2))">
				<game:error messageExpr="'Edge (' + _eventdata.edge.@x1 + ',' + _eventdata.edge.@y1 + ',' + _eventdata.edge.@x2 + ',' + _eventdata.edge.@y2 + ') already has a road'" />
			</transition>			
			<transition event="board.click" cond="(_eventdata.edge.@x1 != state.board.currentVertex.@x || _eventdata.edge.@y1 != state.board.currentVertex.@y) &amp;&amp; (_eventdata.edge.@x2 != state.board.currentVertex.@x || _eventdata.edge.@y2 != state.board.currentVertex.@y)">
				<game:error message="This edge is not adjecent to the placed settlement." />
			</transition>
			<transition event="board.click" target="placement.nextPlayerOrPhase">
				<script><![CDATA[
					delete state.board.currentVertex;
					var player = state.board.players.player[state.board.currentPlayer];
					
					placeEdgeDevelopment("road", player.color, _eventdata.edge.@x1, _eventdata.edge.@y1, _eventdata.edge.@x2, _eventdata.edge.@y2);
					
				]]></script>
				<game:sendWatcherEvent event="'placeEdgeDevelopment'" keyExpr="_eventdata.edge.@x1 + ',' + _eventdata.edge.@y1 + ',' + _eventdata.edge.@x2 + ',' + _eventdata.edge.@y2">
					<param name="color" expr="player.color" />
					<param name="x1" expr="_eventdata.edge.@x1" />
					<param name="y1" expr="_eventdata.edge.@y1" />
					<param name="x2" expr="_eventdata.edge.@x2" />
					<param name="y2" expr="_eventdata.edge.@y2" />
					<param name="type" expr="'road'" />
				</game:sendWatcherEvent>
			</transition>
		</state>
		<state id="placement.nextPlayerOrPhase">
			<transition cond="state.board.firstPlacement == 'true' &amp;&amp; (state.board.currentPlayer >>> 0) + 1 &lt; state.board.players.player.length()" target="placement.buildSettlement">
				<script><![CDATA[
					state.board.currentPlayer = (state.board.currentPlayer.text() >>> 0) + 1;
				]]></script>
				<game:sendWatcherEvent event="'currentPlayerChanged'">					
					<param name="currentPlayer" expr="state.board.currentPlayer" />
				</game:sendWatcherEvent>
			</transition>
			<transition cond="state.board.firstPlacement == 'true' &amp;&amp; (state.board.currentPlayer >>> 0) + 1 >= state.board.players.player.length()" target="placement.buildSettlement">
				<script><![CDATA[
					state.board.firstPlacement = 'false';
				]]></script>
			</transition>
			<transition cond="state.board.firstPlacement != 'true' &amp;&amp; (state.board.currentPlayer >>> 0) > 0" target="placement.buildSettlement">
				<script><![CDATA[
					state.board.currentPlayer = (state.board.currentPlayer.text() >>> 0) - 1;
				]]></script>
				<game:sendWatcherEvent event="'currentPlayerChanged'">
					<param name="currentPlayer" expr="state.board.currentPlayer" />
				</game:sendWatcherEvent>
			</transition>
			<transition cond="state.board.firstPlacement != 'true' &amp;&amp; state.board.currentPlayer &lt;= 0" target="main">
				<script><![CDATA[
					state.board.currentPlayer = 1;
					delete state.board.firstPlacement;
				]]></script>
				<game:sendWatcherEvent event="'board.currentPlayerChanged'">
					<param name="currentPlayer" expr="state.board.currentPlayer" />
				</game:sendWatcherEvent>
			</transition>
		</state>		
	</state>
	<state id="main" initial="main.rollDice">
		<state id="main.rollDice">
			<transition event="board.diceClick" cond="!isCurrentPlayer(_eventdata.gns::player.text())">
				<game:error message="You are not the current player." />
			</transition>
			<transition event="board.diceClick" target="main.checkDiceRoll">
				<script><![CDATA[
					delete state.board.dice;
					
					var die0 = Math.floor(Math.random() * 6.0) + 1;
					var die1 = Math.floor(Math.random() * 6.0) + 1;
					
					state.board.appendChild(<dice><die value={die0} /><die value={die1} /></dice>);
				]]></script>
				<game:sendWatcherEvent event="'diceRolled'">
					<content expr="state.board.dice" />
				</game:sendWatcherEvent>
			</transition>
		</state>
		<state id="main.checkDiceRoll">
			<transition cond="parseInt(state.board.dice.die[0].@value) + parseInt(state.board.dice.die[1].@value) == 7" target="main.handleRollOf7" />
			<transition target="main.distributeResources" />			
		</state>
		<state id="main.handleRollOf7" initial="main.handleRollOf7.discard">
			<state id="main.handleRollOf7.discard">
				<onentry>
					<script>log.info("TODO: Discarding... ");</script>
				</onentry>
				<transition target="main.build" />
			</state>
		</state>
		<state id="main.distributeResources">
			<onentry>
				<script><![CDATA[
					var diceTotal = parseInt(state.board.dice.die[0].@value) + parseInt(state.board.dice.die[1].@value);
					
					for each(var poly in state.board.polys.poly.(@value == diceTotal)) {
						var adjacent = adjacentVertexFromPoly(poly.@x, poly.@y);
						
						for each(var vert in adjacent) {
							for each(var dev in vert.development) {
								var resourceType = state.board.polytypes.polytype.(@type == poly.@type).@produces;
								
								var pr = state.board.players.player.(color == dev.@color).resources.resource.(@type == resourceType);
								
								switch(dev.@type) {
								case "settlement":
									pr.@count = parseInt(pr.@count) + 1;
									break;
								case "city":
									pr.@count = parseInt(pr.@count) + 2;
									break;
								}
							}
						}
					}
				]]></script>
				<game:sendWatcherEvent event="'resourcesDistributed'">
					<content expr="state.board.players" />
				</game:sendWatcherEvent>
			</onentry>
			<transition target="main.build" />
		</state>
		<state id="main.build">
			<transition event="board.endTurn" cond="!isCurrentPlayer(_eventdata.gns::player.text())">
				<game:error message="You are not the current player" />
			</transition>
			<transition event="board.endTurn" target="main.rollDice">
				<script><![CDATA[
					var currentPlayer = parseInt(state.board.currentPlayer);
					
					state.board.currentPlayer = (currentPlayer + 1) % state.board.players.player.length();
				]]></script>
			</transition>
		</state>
	</state>
</scxml>